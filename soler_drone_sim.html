<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOLAR PANEL MONITORING DRONE</title>
    <!-- Add PeerJS for WebRTC connections -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
/* */
        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            text-shadow: 1px 1px 1px black;
            z-index: 100;
            font-size: 18px;
        }

        #controls {
            position: absolute;
            top: 50px;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 1px 1px 1px black;
            z-index: 100;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 0 5px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            background: #2980b9;
        }

        #laptop-screen {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            background-color: #1a1a1a;
            border: 3px solid #444;
            border-radius: 5px;
            z-index: 100;
            color: white;
            overflow: hidden;
        }

        #laptop-header {
            background-color: #444;
            padding: 5px;
            text-align: center;
            font-weight: bold;
            border-bottom: 2px solid #555;
        }

        #thermal-view {
            width: 320px;
            height: 204px;
            background-color: black;
            position: relative;
        }

        .heat-signature {
            position: absolute;
            border-radius: 50%;
            opacity: 0.8;
            filter: blur(5px);
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .status-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff00;
            font-size: 12px;
            font-family: monospace;
        }

        .coordinates {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #00ff00;
            font-size: 12px;
            font-family: monospace;
        }

        .heat-reading {
            position: absolute;
            top: 30px;
            left: 10px;
            color: #00ff00;
            font-size: 12px;
            font-family: monospace;
        }

        .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            height: 2px;
            width: 100%;
            background-color: rgba(0, 255, 0, 0.7);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
        }

        #mission-status {
            position: absolute;
            top: 100px;
            left: 20px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #444;
            border-radius: 5px;
            color: white;
            z-index: 100;
            font-size: 14px;
            max-width: 250px;
        }

        #toggle-view {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #e74c3c;
            z-index: 101;
        }

        #remote-connection {
            position: absolute;
            top: 10px;
            left: 20px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #444;
            border-radius: 5px;
            color: white;
            z-index: 100;
        }
    </style>
</head>

<body>
    <div id="info">SOLAR PANEL MONITORING DRONE</div>
    <div id="controls">
        <button id="start-auto">Auto Monitor</button>
        <button id="manual-control">Manual</button>
        <button id="toggle-thermal">Toggle Thermal View</button>
    </div>

    <div id="mission-status">
        <h3>Mission Status: Standby</h3>
        <p>Search pattern: None</p>
        <p>Panels scanned: 0</p>
        <p>Drone altitude: 5m</p>
    </div>

    <div id="laptop-screen">
        <div id="laptop-header">THERMAL IMAGING SYSTEM</div>
        <div id="thermal-view">
            <div class="status-indicator">STATUS: STANDBY</div>
            <div class="coordinates">POS: 0.0, 0.0</div>
            <div class="heat-reading">HEAT: --Â°C</div>
            <div class="scan-line"></div>
        </div>
    </div>

    <button id="toggle-view">Switch View</button>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.1/three.module.min.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Light blue sky

        // Cameras setup - Main camera and drone POV camera
        const mainCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        mainCamera.position.set(0, 15, 30);
        mainCamera.lookAt(0, 0, 0);

        const dronePOVCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        // Current active camera
        let activeCamera = mainCamera;

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Create terrain
        const terrainSize = 200;
        const terrainResolution = 100;
        const terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainResolution, terrainResolution);
        
        // Create a more natural-looking ground material
        const terrainMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B7355, // Warm brown color for ground
            roughness: 0.98,
            metalness: 0.02,
        });

        // Create a flat terrain with natural variations
        const vertices = terrainGeometry.getAttribute('position').array;
        for (let i = 0; i < vertices.length; i += 3) {
            // Add very slight height variations for natural ground look
            vertices[i + 1] = Math.random() * 0.15 - 0.05; // Slight variations up and down
        }

        terrainGeometry.getAttribute('position').needsUpdate = true;
        terrainGeometry.computeVertexNormals();

        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        terrain.receiveShadow = true;
        scene.add(terrain);

        // Add ground texture detail
        function createGroundDetail() {
            const detailGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, 200, 200);
            const detailMaterial = new THREE.MeshStandardMaterial({
                color: 0x9B8B7B, // Slightly lighter brown for texture
                roughness: 0.95,
                metalness: 0.05,
                transparent: true,
                opacity: 0.5
            });

            const vertices = detailGeometry.getAttribute('position').array;
            for (let i = 0; i < vertices.length; i += 3) {
                // Create more pronounced texture variations
                vertices[i + 2] = (Math.random() * 0.2 - 0.1) * 
                                Math.sin(vertices[i] * 0.1) * 
                                Math.cos(vertices[i + 1] * 0.1);
            }

            detailGeometry.getAttribute('position').needsUpdate = true;
            detailGeometry.computeVertexNormals();

            const detail = new THREE.Mesh(detailGeometry, detailMaterial);
            detail.rotation.x = -Math.PI / 2;
            detail.position.y = 0.01; // Slightly above the base terrain
            detail.receiveShadow = true;
            scene.add(detail);
        }

        createGroundDetail();

        // Adjust lighting for better ground visibility
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Increased ambient light
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); // Adjusted intensity
        directionalLight.position.set(5, 30, 7);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);

        // Create solar panel function
        function createSolarPanel(x, z, rotation = 0) {
            const panelGroup = new THREE.Group();

            // Panel base
            const baseGeometry = new THREE.BoxGeometry(2, 0.1, 4);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x34495E,
                roughness: 0.7,
                metalness: 0.3
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.05;
            panelGroup.add(base);

            // Support structure
            const supportGeometry = new THREE.BoxGeometry(0.2, 1.5, 0.2);
            const supportMaterial = new THREE.MeshStandardMaterial({
                color: 0x7F8C8D,
                roughness: 0.8,
                metalness: 0.2
            });
            const support = new THREE.Mesh(supportGeometry, supportMaterial);
            support.position.set(0, -0.75, 0);
            panelGroup.add(support);

            // Create the folded panel structure
            const panelAngle = Math.PI / 6; // 30 degrees angle

            // Main panel frame
            const frameGeometry = new THREE.BoxGeometry(2.1, 0.15, 4.1);
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0x95A5A6,
                roughness: 0.5,
                metalness: 0.5
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.y = 0.75;
            frame.rotation.x = panelAngle;
            panelGroup.add(frame);

            // Solar cells - create multiple sections for a more realistic look
            const cellSections = 3;
            const cellWidth = 1.8 / cellSections;
            const cellDepth = 3.8;

            for (let i = 0; i < cellSections; i++) {
                const cellGeometry = new THREE.BoxGeometry(cellWidth, 0.05, cellDepth);
                const cellMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1E90FF, // Dodger blue for solar cells
                    roughness: 0.1,
                    metalness: 0.9,
                    emissive: 0x1E90FF,
                    emissiveIntensity: 0.2
                });
                const cells = new THREE.Mesh(cellGeometry, cellMaterial);
                cells.position.set(
                    (i - (cellSections-1)/2) * cellWidth,
                    0.75 + Math.sin(panelAngle) * 0.1,
                    Math.cos(panelAngle) * 0.1
                );
                cells.rotation.x = panelAngle;
                panelGroup.add(cells);
            }

            // Add grid lines on solar cells
            const gridLines = [];
            const gridMaterial = new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.3 });
            
            // Vertical lines
            for (let i = 0; i <= cellSections; i++) {
                const points = [];
                points.push(new THREE.Vector3((i - cellSections/2) * cellWidth, 0.75, 0));
                points.push(new THREE.Vector3((i - cellSections/2) * cellWidth, 0.75 + Math.sin(panelAngle) * 2, Math.cos(panelAngle) * 2));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, gridMaterial);
                line.rotation.x = panelAngle;
                panelGroup.add(line);
            }

            // Horizontal lines
            for (let i = 0; i <= 4; i++) {
                const points = [];
                points.push(new THREE.Vector3(-cellWidth * cellSections/2, 0.75, i * cellDepth/4 - cellDepth/2));
                points.push(new THREE.Vector3(cellWidth * cellSections/2, 0.75, i * cellDepth/4 - cellDepth/2));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, gridMaterial);
                line.rotation.x = panelAngle;
                panelGroup.add(line);
            }

            // Add mounting brackets
            const bracketGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.1);
            const bracketMaterial = new THREE.MeshStandardMaterial({
                color: 0x7F8C8D,
                roughness: 0.8,
                metalness: 0.2
            });

            // Add brackets at the corners
            const bracketPositions = [
                { x: -1, z: -2 },
                { x: 1, z: -2 },
                { x: -1, z: 2 },
                { x: 1, z: 2 }
            ];

            bracketPositions.forEach(pos => {
                const bracket = new THREE.Mesh(bracketGeometry, bracketMaterial);
                bracket.position.set(pos.x, 0.75, pos.z);
                bracket.rotation.x = panelAngle;
                panelGroup.add(bracket);
            });

            panelGroup.position.set(x, 0, z);
            panelGroup.rotation.y = rotation;
            scene.add(panelGroup);

            // Add thermal properties for detection
            panelGroup.userData.temperature = 45 + Math.random() * 15; // Normal range 45-60Â°C
            // Increase probability of abnormal temperatures
            if (Math.random() < 0.65) { // Increased from 0.1 to 0.25 (25% chance of abnormal temperature)
                if (Math.random() < 0.8) { // Increased chance of high temperature (70% of abnormal cases)
                    panelGroup.userData.temperature = 65 + Math.random() * 10; // Hot panel (65-75Â°C)
                } else {
                    panelGroup.userData.temperature = 35 + Math.random() * 5; // Cold panel (35-40Â°C)
                }
            }
            panelGroup.userData.isScanned = false;

            return panelGroup;
        }

        // Create solar farm
        const solarPanels = [];
        const panelSpacing = 6; // Increased spacing for better organization
        const rows = 15; // Reduced number of rows
        const cols = 15; // Reduced number of columns

        // Create panels in a more organized grid with gaps for maintenance
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Skip panels that would be in the center paths
                if ((row === Math.floor(rows/2) || col === Math.floor(cols/2)) && 
                    (row > Math.floor(rows/2) - 2 && row < Math.floor(rows/2) + 2) &&
                    (col > Math.floor(cols/2) - 2 && col < Math.floor(cols/2) + 2)) {
                    continue;
                }

                const x = (col - cols/2) * panelSpacing;
                const z = (row - rows/2) * panelSpacing;
                const rotation = Math.random() * Math.PI * 2; // Random rotation for variety
                solarPanels.push(createSolarPanel(x, z, rotation));
            }
        }

        // Add some maintenance equipment
        function createMaintenanceEquipment(x, z) {
            const equipmentGroup = new THREE.Group();

            // Base
            const baseGeometry = new THREE.BoxGeometry(2, 0.5, 3);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x34495E,
                roughness: 0.8,
                metalness: 0.2
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.25;
            equipmentGroup.add(base);

            // Equipment box
            const boxGeometry = new THREE.BoxGeometry(1.5, 1, 2);
            const boxMaterial = new THREE.MeshStandardMaterial({
                color: 0x2C3E50,
                roughness: 0.7,
                metalness: 0.3
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.y = 1;
            equipmentGroup.add(box);

            equipmentGroup.position.set(x, 0, z);
            scene.add(equipmentGroup);

            return equipmentGroup;
        }

        // Add maintenance equipment at the corners of the solar farm
        createMaintenanceEquipment(-40, -40);
        createMaintenanceEquipment(40, 40);
        createMaintenanceEquipment(-40, 40);
        createMaintenanceEquipment(40, -40);

        // Create drone body
        const droneGroup = new THREE.Group();

        // Drone movement properties
        const droneMovement = {
            velocity: new THREE.Vector3(0, 0, 0),
            targetPosition: new THREE.Vector3(0, 5, 0),
            maxSpeed: 20, // Maximum speed
            acceleration: 8, // How quickly to reach target speed
            dampening: 0.92, // Dampening factor for smooth deceleration
            rotationSpeed: 2 // Rotation speed
        };

        // Main body - updated design with more angular shape
        const bodyGeometry = new THREE.BoxGeometry(1.8, 0.3, 1.8);
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0xE8F6F3, // Light mint/cyan
            metalness: 0.6,
            roughness: 0.3
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.castShadow = true;
        droneGroup.add(body);

        // Add top body shell with sleek design
        const topShellGeometry = new THREE.BoxGeometry(1.6, 0.15, 1.6);
        const topShellMaterial = new THREE.MeshStandardMaterial({
            color: 0x87CEEB, // Sky blue
            metalness: 0.7,
            roughness: 0.2
        });
        const topShell = new THREE.Mesh(topShellGeometry, topShellMaterial);
        topShell.position.y = 0.2;
        // Add slight angle to top shell for aerodynamic look
        topShell.rotation.set(0.1, Math.PI * 0.25, 0);
        droneGroup.add(topShell);

        // Create angled arms for the rotors
        const armGeometry = new THREE.BoxGeometry(1.2, 0.12, 0.25);
        const armMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xF9E79F, // Light golden yellow
            metalness: 0.5,
            roughness: 0.4
        });

        // Position the arms at angles
        const armPositions = [
            { x: 1.2, y: 0, z: 1.2, rotation: Math.PI / 4 },
            { x: -1.2, y: 0, z: 1.2, rotation: -Math.PI / 4 },
            { x: -1.2, y: 0, z: -1.2, rotation: Math.PI / 4 },
            { x: 1.2, y: 0, z: -1.2, rotation: -Math.PI / 4 }
        ];

        // Create rotors and arms
        const rotors = [];
        armPositions.forEach((pos, i) => {
            // Create angled arm
            const arm = new THREE.Mesh(armGeometry, armMaterial);
            arm.position.set(pos.x * 0.7, 0, pos.z * 0.7);
            arm.rotation.y = pos.rotation;
            // Add upward angle to arms
            arm.rotation.x = -0.1;
            arm.castShadow = true;
            droneGroup.add(arm);

            // Create propeller group
            const propellerGroup = new THREE.Group();
            
            // Create two crossed propeller blades
            const bladeGeometry = new THREE.BoxGeometry(1.0, 0.02, 0.12);
            const bladeMaterial = new THREE.MeshStandardMaterial({
                color: 0xFDEBD0, // Light peach
                metalness: 0.8,
                roughness: 0.2
            });

            // First blade pair
            const blade1 = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade1.castShadow = true;
            propellerGroup.add(blade1);

            // Second blade pair (perpendicular)
            const blade2 = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade2.rotation.y = Math.PI / 2;
            blade2.castShadow = true;
            propellerGroup.add(blade2);

            // Add propeller hub
            const hubGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.05, 16);
            const hubMaterial = new THREE.MeshStandardMaterial({
                color: 0x87CEEB, // Sky blue
                metalness: 0.9,
                roughness: 0.1
            });
            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
            hub.rotation.x = Math.PI / 2;
            propellerGroup.add(hub);

            // Position the propeller group
            propellerGroup.position.set(pos.x, 0.1, pos.z);
            droneGroup.add(propellerGroup);
            rotors.push(propellerGroup);

            // Add motor housing
            const motorHousingGeometry = new THREE.CylinderGeometry(0.12, 0.15, 0.1, 16);
            const motorHousing = new THREE.Mesh(motorHousingGeometry, new THREE.MeshStandardMaterial({
                color: 0xF9E79F, // Light golden yellow (matching arms)
                metalness: 0.7,
                roughness: 0.3
            }));
            motorHousing.position.set(pos.x, 0.05, pos.z);
            motorHousing.rotation.x = Math.PI / 2;
            droneGroup.add(motorHousing);
        });

        // Add landing gear
        const legGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.1);
        const legMaterial = new THREE.MeshStandardMaterial({
            color: 0xE8F6F3, // Light mint/cyan (matching body)
            metalness: 0.6,
            roughness: 0.3
        });

        // Add four legs
        const legPositions = [
            { x: 0.6, z: 0.6 },
            { x: -0.6, z: 0.6 },
            { x: -0.6, z: -0.6 },
            { x: 0.6, z: -0.6 }
        ];

        legPositions.forEach(pos => {
            const leg = new THREE.Mesh(legGeometry, legMaterial);
            leg.position.set(pos.x, -0.2, pos.z);
            droneGroup.add(leg);

            // Add foot pad
            const footGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.2);
            const foot = new THREE.Mesh(footGeometry, new THREE.MeshStandardMaterial({
                color: 0x87CEEB, // Sky blue
                metalness: 0.7,
                roughness: 0.2
            }));
            foot.position.set(pos.x, -0.4, pos.z);
            droneGroup.add(foot);
        });

        // Add body details
        const bodyDetailGeometry = new THREE.BoxGeometry(1.8, 0.45, 1.8);
        const bodyDetailMaterial = new THREE.MeshStandardMaterial({
            color: 0x3498DB, // Bright blue
            metalness: 0.9,
            roughness: 0.1
        });
        const bodyDetail = new THREE.Mesh(bodyDetailGeometry, bodyDetailMaterial);
        bodyDetail.position.y = 0.05;
        bodyDetail.castShadow = true;
        droneGroup.add(bodyDetail);

        // Modern camera housing
        const cameraHousingGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.4, 12);
        const cameraHousingMaterial = new THREE.MeshStandardMaterial({
            color: 0x2C3E50, // Dark blue-gray
            metalness: 0.8,
            roughness: 0.2
        });
        const droneCamera = new THREE.Mesh(cameraHousingGeometry, cameraHousingMaterial);
        droneCamera.position.y = -0.3;
        droneCamera.rotation.x = Math.PI / 2;
        droneCamera.castShadow = true;
        droneGroup.add(droneCamera);

        // Camera lens with blue accent
        const lensGeometry = new THREE.SphereGeometry(0.12, 16, 16);
        const lensMaterial = new THREE.MeshStandardMaterial({
            color: 0x87CEEB, // Sky blue
            metalness: 0.9,
            roughness: 0.1,
            emissive: 0x87CEEB,
            emissiveIntensity: 0.2
        });
        const lens = new THREE.Mesh(lensGeometry, lensMaterial);
        lens.position.y = -0.5;
        droneGroup.add(lens);

        // Thermal Camera/Sensor with modern design
        const thermalSensorGeometry = new THREE.BoxGeometry(0.25, 0.25, 0.25);
        const thermalSensorMaterial = new THREE.MeshStandardMaterial({
            color: 0x87CEEB, // Sky blue
            metalness: 0.9,
            roughness: 0.1,
            emissive: 0x87CEEB,
            emissiveIntensity: 0.3
        });
        const thermalSensor = new THREE.Mesh(thermalSensorGeometry, thermalSensorMaterial);
        thermalSensor.position.set(0.4, -0.3, 0);
        droneGroup.add(thermalSensor);

        // Add LED status lights
        const ledGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const ledMaterial = new THREE.MeshStandardMaterial({
            color: 0x87CEEB, // Sky blue
            emissive: 0x87CEEB,
            emissiveIntensity: 0.5
        });

        // Add LEDs at strategic positions
        const ledPositions = [
            { x: 0.8, y: 0, z: 0.8 },
            { x: -0.8, y: 0, z: 0.8 },
            { x: -0.8, y: 0, z: -0.8 },
            { x: 0.8, y: 0, z: -0.8 }
        ];

        ledPositions.forEach(pos => {
            const led = new THREE.Mesh(ledGeometry, ledMaterial);
            led.position.set(pos.x, pos.y, pos.z);
            droneGroup.add(led);
        });

        // Add drone POV camera
        dronePOVCamera.position.set(0, -0.2, 0);
        dronePOVCamera.rotation.x = Math.PI / 2;
        droneGroup.add(dronePOVCamera);

        // Spotlight to represent the search light
        const spotlight = new THREE.SpotLight(0xFFFFFF, 2);
        spotlight.position.set(0, -0.5, 0);
        spotlight.angle = 0.3;
        spotlight.penumbra = 0.2;
        spotlight.castShadow = true;
        spotlight.distance = 30;

        const spotlightTarget = new THREE.Object3D();
        spotlightTarget.position.set(0, -10, 0);
        scene.add(spotlightTarget);
        spotlight.target = spotlightTarget;

        droneGroup.add(spotlight);

        // Position the drone
        droneGroup.position.y = 5;
        scene.add(droneGroup);

        // Create trees function
        function createTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();

            // Get height at position
            const heightOffset = getTerrainHeightAt(x, z);

            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 2 * scale, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.castShadow = true;
            trunk.position.y = 1 * scale;
            treeGroup.add(trunk);

            // Tree top
            const topGeometry = new THREE.ConeGeometry(1 * scale, 3 * scale, 8);
            const topMaterial = new THREE.MeshStandardMaterial({ color: 0x2E8B57 });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = (3 * scale);
            top.castShadow = true;
            treeGroup.add(top);

            treeGroup.position.set(x, heightOffset, z);
            scene.add(treeGroup);

            return treeGroup;
        }

        // Function to get terrain height at a specific position
        function getTerrainHeightAt(x, z) {
            // Convert world coordinates to terrain coordinates
            const terrainHalfSize = terrainSize / 2;
            const terrainX = ((x + terrainHalfSize) / terrainSize) * terrainResolution;
            const terrainZ = ((z + terrainHalfSize) / terrainSize) * terrainResolution;

            // Simplified height calculation (approximation)
            let height = Math.sin(x * 0.05) * Math.cos(z * 0.05) * 3;
            height += Math.sin(x * 0.1 + 10) * Math.cos(z * 0.1) * 2;
            height += Math.sin(x * 0.2 + 30) * Math.cos(z * 0.2 + 5) * 1;

            return height;
        }

        // Create trees and vegetation
        const trees = [];
        for (let i = 0; i < 200; i++) {
            const x = Math.random() * terrainSize - terrainSize / 2;
            const z = Math.random() * terrainSize - terrainSize / 2;
            const scale = Math.random() * 0.5 + 0.7;

            // Don't place trees in water
            if (getTerrainHeightAt(x, z) > -1.5) {
                trees.push(createTree(x, z, scale));
            }
        }

        // Add a lighthouse
        function createLighthouse(x, z) {
            const lighthouseGroup = new THREE.Group();
            const heightOffset = getTerrainHeightAt(x, z);

            // Base
            const baseGeometry = new THREE.CylinderGeometry(3, 3.5, 2, 16);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0xDDDDDD
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 1;
            lighthouseGroup.add(base);

            // Tower
            const towerGeometry = new THREE.CylinderGeometry(2, 2.5, 12, 16);
            const towerMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.8
            });
            const tower = new THREE.Mesh(towerGeometry, towerMaterial);
            tower.position.y = 8;
            lighthouseGroup.add(tower);

            // Red stripes
            const stripeCount = 4;
            for (let i = 0; i < stripeCount; i++) {
                const stripeGeometry = new THREE.CylinderGeometry(2.01, 2.01, 1, 16);
                const stripeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFF0000,
                    roughness: 0.8
                });
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.position.y = 4 + i * 3;
                lighthouseGroup.add(stripe);
            }

            // Light housing
            const housingGeometry = new THREE.CylinderGeometry(2.5, 2.5, 2, 16);
            const housingMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.5
            });
            const housing = new THREE.Mesh(housingGeometry, housingMaterial);
            housing.position.y = 15;
            lighthouseGroup.add(housing);

            // Light dome
            const domeGeometry = new THREE.SphereGeometry(2, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const domeMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF00,
                transparent: true,
                opacity: 0.8,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.5
            });
            const dome = new THREE.Mesh(domeGeometry, domeMaterial);
            dome.position.y = 16;
            lighthouseGroup.add(dome);

            // Actual light source
            const light = new THREE.PointLight(0xFFFF00, 1, 100);
            light.position.set(0, 16, 0);
            lighthouseGroup.add(light);

            lighthouseGroup.position.set(x, heightOffset, z);
            scene.add(lighthouseGroup);

            return lighthouseGroup;
        }

        // Add a lighthouse near water
        createLighthouse(-60, -80);

        // Create power station function
        function createPowerStation(x, z) {
            const powerStationGroup = new THREE.Group();
            const heightOffset = getTerrainHeightAt(x, z);

            // Main control building
            const buildingGeometry = new THREE.BoxGeometry(15, 8, 20);
            const buildingMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.7,
                metalness: 0.2
            });
            const mainBuilding = new THREE.Mesh(buildingGeometry, buildingMaterial);
            mainBuilding.position.y = 4;
            mainBuilding.castShadow = true;
            mainBuilding.receiveShadow = true;
            powerStationGroup.add(mainBuilding);

            // Roof
            const roofGeometry = new THREE.BoxGeometry(16, 1, 21);
            const roofMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 0.8
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 8.5;
            roof.castShadow = true;
            powerStationGroup.add(roof);

            // Add transformers
            const transformerCount = 4;
            for (let i = 0; i < transformerCount; i++) {
                const transformerGroup = new THREE.Group();
                
                // Base
                const baseGeometry = new THREE.BoxGeometry(3, 1, 3);
                const baseMaterial = new THREE.MeshStandardMaterial({
                    color: 0x888888,
                    roughness: 0.7
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                transformerGroup.add(base);

                // Main transformer body
                const transformerGeometry = new THREE.BoxGeometry(2, 4, 2);
                const transformerMaterial = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const transformer = new THREE.Mesh(transformerGeometry, transformerMaterial);
                transformer.position.y = 2.5;
                transformerGroup.add(transformer);

                // Transformer insulators (the white cylindrical parts)
                const insulatorCount = 3;
                for (let j = 0; j < insulatorCount; j++) {
                    const insulatorGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
                    const insulatorMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.3
                    });
                    const insulator = new THREE.Mesh(insulatorGeometry, insulatorMaterial);
                    insulator.position.set(
                        (j - 1) * 0.5,
                        4.5,
                        0
                    );
                    transformerGroup.add(insulator);
                }

                // Position transformer
                transformerGroup.position.set(
                    -10 + i * 6,
                    0.5,
                    12
                );
                powerStationGroup.add(transformerGroup);
            }

            // Add power lines
            const poleHeight = 15;
            const poleCount = 3;
            for (let i = 0; i < poleCount; i++) {
                // Create pole
                const poleGeometry = new THREE.CylinderGeometry(0.3, 0.3, poleHeight, 8);
                const poleMaterial = new THREE.MeshStandardMaterial({
                    color: 0x4d4d4d,
                    roughness: 0.8
                });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.set(-10 + i * 10, poleHeight/2, -15);
                powerStationGroup.add(pole);

                // Create cross beam
                const crossBeamGeometry = new THREE.BoxGeometry(6, 0.3, 0.3);
                const crossBeam = new THREE.Mesh(crossBeamGeometry, poleMaterial);
                crossBeam.position.set(-10 + i * 10, poleHeight - 1, -15);
                powerStationGroup.add(crossBeam);

                // Add power line insulators
                for (let j = 0; j < 3; j++) {
                    const insulatorGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
                    const insulatorMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.3
                    });
                    const insulator = new THREE.Mesh(insulatorGeometry, insulatorMaterial);
                    insulator.position.set(
                        -10 + i * 10 + (j - 1) * 2,
                        poleHeight - 1.5,
                        -15
                    );
                    powerStationGroup.add(insulator);
                }
            }

            // Add power lines between poles
            for (let i = 0; i < poleCount - 1; i++) {
                for (let j = 0; j < 3; j++) {
                    const lineGeometry = new THREE.CylinderGeometry(0.05, 0.05, 10, 8);
                    const lineMaterial = new THREE.MeshStandardMaterial({
                        color: 0x000000,
                        roughness: 0.8
                    });
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.position.set(-5 + i * 10, poleHeight - 1.5, -15);
                    line.rotation.z = Math.PI / 2;
                    powerStationGroup.add(line);
                }
            }

            // Add warning signs
            const signGeometry = new THREE.PlaneGeometry(2, 2);
            const signMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                side: THREE.DoubleSide
            });
            
            // Add multiple warning signs around the station
            const signPositions = [
                { x: -8, z: 12, rotation: 0 },
                { x: 8, z: 12, rotation: 0 },
                { x: 0, z: -12, rotation: Math.PI }
            ];

            signPositions.forEach(pos => {
                const sign = new THREE.Mesh(signGeometry, signMaterial);
                sign.position.set(pos.x, 1, pos.z);
                sign.rotation.y = pos.rotation;
                powerStationGroup.add(sign);
            });

            powerStationGroup.position.set(x, heightOffset, z);
            scene.add(powerStationGroup);

            return powerStationGroup;
        }

        // Add power stations of varying sizes around the perimeter
        // Main large power station
        createPowerStation(60, 60);
        
        // Additional power stations with different scales
        const powerStationLocations = [
            { x: -70, z: -70, scale: 0.6 }, // Small - Southwest
            { x: 70, z: -70, scale: 0.5 },  // Small - Southeast
            { x: -70, z: 70, scale: 0.7 },  // Small - Northwest
            { x: -40, z: -85, scale: 0.8 }, // Medium - South
            { x: 85, z: 0, scale: 0.9 },    // Medium - East
            { x: -85, z: 0, scale: 1.2 }    // Large - West
        ];

        powerStationLocations.forEach(station => {
            const group = createPowerStation(station.x, station.z);
            group.scale.set(station.scale, station.scale, station.scale);
        });


        // Controls
        const keys = {};
        const moveSpeed = 0.2;
        const rotateSpeed = 0.05;

        document.addEventListener('keydown', (event) => {
            keys[event.key] = true;
        });

        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            mainCamera.aspect = window.innerWidth / window.innerHeight;
            mainCamera.updateProjectionMatrix();
            dronePOVCamera.aspect = window.innerWidth / window.innerHeight;
            dronePOVCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Toggle camera view
        document.getElementById('toggle-view').addEventListener('click', () => {
            activeCamera = activeCamera === mainCamera ? dronePOVCamera : mainCamera;
        });

        // Thermal view toggle
        let thermalViewActive = false;
        document.getElementById('toggle-thermal').addEventListener('click', () => {
            thermalViewActive = !thermalViewActive;
            updateThermalDisplay();
        });

        // Mission control
        let autoMode = false;
        let missionPath = [];
        let currentPathIndex = 0;
        let missionStatus = "Standby";
        let searchPattern = "None";
        let panelsScanned = 0;

        // Update mission status display
        function updateMissionStatus() {
            const statusElem = document.getElementById('mission-status');
            statusElem.innerHTML = `
                <h3>Mission Status: ${missionStatus}</h3>
                <p>Search pattern: ${searchPattern}</p>
                <p>Panels scanned: ${panelsScanned}</p>
                <p>Drone altitude: ${droneGroup.position.y.toFixed(1)}m</p>
            `;
        }

        // Automatic search mode
        document.getElementById('start-auto').addEventListener('click', () => {
            autoMode = true;
            manualMode = false;

            // Increase speed for automatic search
            droneMovement.maxSpeed = 40;
            droneMovement.acceleration = 15;

            // Generate a search pattern - spiral outward
            missionPath = generateSearchPattern();
            currentPathIndex = 0;
            missionStatus = "Searching";
            searchPattern = "Spiral Outward";
            updateMissionStatus();
        });

        // Manual control mode
        let manualMode = true;
        document.getElementById('manual-control').addEventListener('click', () => {
            autoMode = false;
            manualMode = true;

            // Reset to normal speed for manual control
            droneMovement.maxSpeed = 20;
            droneMovement.acceleration = 8;

            missionStatus = "Manual Control";
            searchPattern = "None";
            updateMissionStatus();
        });

        // Generate a search pattern
        function generateSearchPattern() {
            const path = [];
            // Spiral pattern
            const spiralPoints = 100;
            const maxRadius = 80;

            for (let i = 0; i < spiralPoints; i++) {
                const angle = 0.3 * i;
                const radius = (i / spiralPoints) * maxRadius;
                const x = radius * Math.cos(angle);
                const z = radius * Math.sin(angle);
                path.push({ x, y: 20, z }); // y is altitude
            }

            return path;
        }

        // Update thermal display
        function updateThermalDisplay() {
            const thermalView = document.getElementById('thermal-view');
            const statusIndicator = thermalView.querySelector('.status-indicator');
            const coordinates = thermalView.querySelector('.coordinates');
            const heatReading = thermalView.querySelector('.heat-reading');

            // Clear existing heat signatures
            const existingSignatures = thermalView.querySelectorAll('.heat-signature');
            existingSignatures.forEach(sig => sig.remove());

            if (thermalViewActive) {
                // Update status
                statusIndicator.textContent = `STATUS: ACTIVE - PANEL SCAN`;
                statusIndicator.style.color = "#ff0000";

                // Update coordinates
                coordinates.textContent = `POS: ${droneGroup.position.x.toFixed(1)}, ${droneGroup.position.z.toFixed(1)}`;

                // Detect solar panels within range
                const maxDetectionRange = 30; // meters
                let closestPanelDistance = Infinity;
                let closestPanel = null;

                solarPanels.forEach(panel => {
                    const dx = panel.position.x - droneGroup.position.x;
                    const dz = panel.position.z - droneGroup.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    // Check if panel is within detection range
                    if (distance < maxDetectionRange) {
                        // Mark panel as scanned
                        if (!panel.userData.isScanned) {
                            panel.userData.isScanned = true;
                            panelsScanned++;
                            updateMissionStatus();
                        }

                        // Convert 3D world position to 2D screen position
                        const screenX = (dx / maxDetectionRange) * 160 + 160;
                        const screenY = (dz / maxDetectionRange) * 100 + 100;

                        // Create a heat signature blob
                        const heatSig = document.createElement('div');
                        heatSig.className = 'heat-signature';

                        // Size based on distance
                        const size = Math.max(5, 20 - (distance / maxDetectionRange) * 15);

                        // Color based on panel temperature
                        const temp = panel.userData.temperature;
                        let color;
                        if (temp < 40) {
                            // Too cold - potential malfunction
                            color = 'rgba(0, 0, 255, 0.8)';
                        } else if (temp < 45) {
                            // Below optimal
                            color = 'rgba(0, 255, 200, 0.8)';
                        } else if (temp <= 60) {
                            // Normal operating temperature
                            color = 'rgba(0, 255, 0, 0.8)';
                        } else if (temp <= 65) {
                            // Getting hot
                            color = 'rgba(255, 255, 0, 0.8)';
                        } else if (temp <= 70) {
                            // Too hot - warning
                            color = 'rgba(255, 150, 0, 0.8)';
                        } else {
                            // Critical temperature - danger
                            color = 'rgba(255, 0, 0, 0.8)';
                        }

                        heatSig.style.width = `${size}px`;
                        heatSig.style.height = `${size}px`;
                        heatSig.style.backgroundColor = color;
                        heatSig.style.left = `${screenX}px`;
                        heatSig.style.top = `${screenY}px`;

                        // Add tooltip with temperature
                        heatSig.title = `Panel Temperature: ${temp.toFixed(1)}Â°C`;

                        thermalView.appendChild(heatSig);

                        // Track closest panel
                        if (distance < closestPanelDistance) {
                            closestPanelDistance = distance;
                            closestPanel = panel;
                        }

                        // Visual feedback in 3D scene
                        panel.traverse(child => {
                            if (child.isMesh) {
                                child.material.emissive = new THREE.Color(color);
                                child.material.emissiveIntensity = 0.5;
                            }
                        });
                    }
                });

                // Update heat reading for the closest panel
                if (closestPanel) {
                    const temp = closestPanel.userData.temperature;
                    heatReading.textContent = `TEMP: ${temp.toFixed(1)}Â°C`;
                    if (temp > 65) {
                        heatReading.style.color = "#ff0000"; // Red for high temperature
                    } else if (temp < 40) {
                        heatReading.style.color = "#0000ff"; // Blue for low temperature
                    } else {
                        heatReading.style.color = "#00ff00"; // Green for normal temperature
                    }
                } else {
                    heatReading.textContent = `TEMP: --Â°C`;
                    heatReading.style.color = "#00ff00";
                }
            } else {
                // Reset panel appearances when thermal view is off
                solarPanels.forEach(panel => {
                    panel.traverse(child => {
                        if (child.isMesh) {
                            child.material.emissive = new THREE.Color(0x000000);
                            child.material.emissiveIntensity = 0;
                        }
                    });
                });

                // Thermal view inactive
                statusIndicator.textContent = `STATUS: STANDBY`;
                statusIndicator.style.color = "#00ff00";
                coordinates.textContent = `POS: --, --`;
                heatReading.textContent = `TEMP: --Â°C`;
                heatReading.style.color = "#00ff00";
            }
        }

        // Add temperature legend
        const legend = document.createElement('div');
        legend.style.position = 'absolute';
        legend.style.right = '20px';
        legend.style.top = '50%';
        legend.style.transform = 'translateY(-50%)';
        legend.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        legend.style.padding = '10px';
        legend.style.borderRadius = '5px';
        legend.style.color = 'white';
        legend.style.fontSize = '12px';
        legend.innerHTML = `
            <div style="margin-bottom: 5px;">Temperature Legend:</div>
            <div style="display: flex; align-items: center; margin: 2px 0;">
                <div style="width: 20px; height: 20px; background: rgba(255, 0, 0, 0.8); margin-right: 5px;"></div>
                <span>>70Â°C (Critical)</span>
            </div>
            <div style="display: flex; align-items: center; margin: 2px 0;">
                <div style="width: 20px; height: 20px; background: rgba(255, 150, 0, 0.8); margin-right: 5px;"></div>
                <span>65-70Â°C (Warning)</span>
            </div>
            <div style="display: flex; align-items: center; margin: 2px 0;">
                <div style="width: 20px; height: 20px; background: rgba(255, 255, 0, 0.8); margin-right: 5px;"></div>
                <span>60-65Â°C (High)</span>
            </div>
            <div style="display: flex; align-items: center; margin: 2px 0;">
                <div style="width: 20px; height: 20px; background: rgba(0, 255, 0, 0.8); margin-right: 5px;"></div>
                <span>45-60Â°C (Normal)</span>
            </div>
            <div style="display: flex; align-items: center; margin: 2px 0;">
                <div style="width: 20px; height: 20px; background: rgba(0, 255, 200, 0.8); margin-right: 5px;"></div>
                <span>40-45Â°C (Low)</span>
            </div>
            <div style="display: flex; align-items: center; margin: 2px 0;">
                <div style="width: 20px; height: 20px; background: rgba(0, 0, 255, 0.8); margin-right: 5px;"></div>
                <span><40Â°C (Too Cold)</span>
            </div>
        `;
        document.body.appendChild(legend);

        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Rotate the rotors for effect
            rotors.forEach((rotor, i) => {
                rotor.rotation.y += (i % 2 ? 0.5 : -0.5);
            });

            // Handle automatic search mode
            if (autoMode) {
                if (currentPathIndex < missionPath.length) {
                    const target = missionPath[currentPathIndex];

                    // Set the target position for smooth movement
                    droneMovement.targetPosition.set(target.x, target.y, target.z);

                    // Calculate distance to target
                    const distance = droneGroup.position.distanceTo(droneMovement.targetPosition);

                    if (distance > 1) {
                        // Calculate direction vector
                        const direction = new THREE.Vector3(
                            droneMovement.targetPosition.x - droneGroup.position.x,
                            droneMovement.targetPosition.y - droneGroup.position.y,
                            droneMovement.targetPosition.z - droneGroup.position.z
                        ).normalize();

                        // Calculate target velocity based on distance and max speed
                        const targetSpeed = Math.min(droneMovement.maxSpeed, distance);

                        // Apply acceleration towards the target speed
                        droneMovement.velocity.x += direction.x * droneMovement.acceleration * delta;
                        droneMovement.velocity.y += direction.y * droneMovement.acceleration * delta;
                        droneMovement.velocity.z += direction.z * droneMovement.acceleration * delta;

                        // Clamp velocity to max speed
                        const speed = droneMovement.velocity.length();
                        if (speed > targetSpeed) {
                            droneMovement.velocity.multiplyScalar(targetSpeed / speed);
                        }

                        // Gradually apply damping to smooth out movement
                        droneMovement.velocity.multiplyScalar(Math.pow(droneMovement.dampening, delta * 10));

                        // Update position
                        droneGroup.position.add(droneMovement.velocity.clone().multiplyScalar(delta));

                        // Gradually rotate the drone to face movement direction
                        if (droneMovement.velocity.length() > 0.1) {
                            const targetRotation = Math.atan2(droneMovement.velocity.x, -droneMovement.velocity.z);
                            const deltaRotation = targetRotation - droneGroup.rotation.y;

                            // Normalize to the shortest rotation path
                            let normalizedDelta = deltaRotation;
                            while (normalizedDelta > Math.PI) normalizedDelta -= Math.PI * 2;
                            while (normalizedDelta < -Math.PI) normalizedDelta += Math.PI * 2;

                            // Apply rotation with smooth interpolation
                            droneGroup.rotation.y += normalizedDelta * Math.min(delta * droneMovement.rotationSpeed, 1);
                        }
                    } else {
                        // We've reached the target, move to the next waypoint
                        currentPathIndex++;

                        // Reset velocity when reaching a waypoint for smoother transitions
                        droneMovement.velocity.multiplyScalar(0.5);
                    }
                } else {
                    missionStatus = "Search Complete";
                    updateMissionStatus();
                }
            }

            // Handle manual controls
            if (manualMode) {
                // Initialize movement vector
                const movement = new THREE.Vector3(0, 0, 0);

                if (keys['ArrowUp']) {
                    movement.z -= moveSpeed;
                }
                if (keys['ArrowDown']) {
                    movement.z += moveSpeed;
                }
                if (keys['ArrowLeft']) {
                    movement.x -= moveSpeed;
                }
                if (keys['ArrowRight']) {
                    movement.x += moveSpeed;
                }
                if (keys['w']) {
                    movement.y += moveSpeed;
                }
                if (keys['s']) {
                    movement.y -= moveSpeed;
                }

                // Apply rotation to movement vector to move in the direction the drone is facing
                movement.applyAxisAngle(new THREE.Vector3(0, 1, 0), droneGroup.rotation.y);

                // Apply movement with smooth acceleration
                droneMovement.velocity.x += movement.x * droneMovement.acceleration * delta;
                droneMovement.velocity.y += movement.y * droneMovement.acceleration * delta;
                droneMovement.velocity.z += movement.z * droneMovement.acceleration * delta;

                // Apply damping for deceleration when no keys are pressed
                droneMovement.velocity.multiplyScalar(Math.pow(droneMovement.dampening, delta * 10));

                // Update position
                droneGroup.position.add(droneMovement.velocity.clone().multiplyScalar(delta));

                // Don't let the drone go below ground
                if (droneGroup.position.y < 0.5) {
                    droneGroup.position.y = 0.5;
                    droneMovement.velocity.y = 0;
                }

                // Handle rotation
                if (keys['q']) {
                    droneGroup.rotation.y += rotateSpeed;
                }
                if (keys['e']) {
                    droneGroup.rotation.y -= rotateSpeed;
                }
            }

            // Update spotlight direction to match drone rotation
            spotlightTarget.position.x = droneGroup.position.x + 5 * Math.sin(droneGroup.rotation.y);
            spotlightTarget.position.z = droneGroup.position.z - 5 * Math.cos(droneGroup.rotation.y);
            spotlightTarget.position.y = -5;

            // Update camera to follow drone
            activeCamera.position.x = droneGroup.position.x + 10 * Math.sin(droneGroup.rotation.y);
            activeCamera.position.z = droneGroup.position.z + 10 * Math.cos(droneGroup.rotation.y);
            activeCamera.position.y = droneGroup.position.y + 5;
            activeCamera.lookAt(droneGroup.position);

            // Update thermal display
            updateThermalDisplay();

            renderer.render(scene, activeCamera);
        }

        animate();
    </script>
</body>

</html>